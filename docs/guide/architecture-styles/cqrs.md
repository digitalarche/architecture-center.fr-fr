---
title: Style d’architecture CQRS
description: Décrit les avantages, les inconvénients et les bonnes pratiques relatifs aux architectures CQRS
author: MikeWasson
ms.date: 08/30/2018
ms.openlocfilehash: ba7af25f940a01e184279c4665f8fce8ebb71b23
ms.sourcegitcommit: ae8a1de6f4af7a89a66a8339879843d945201f85
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 08/31/2018
ms.locfileid: "43325922"
---
# <a name="cqrs-architecture-style"></a><span data-ttu-id="93310-103">Style d’architecture CQRS</span><span class="sxs-lookup"><span data-stu-id="93310-103">CQRS architecture style</span></span>

<span data-ttu-id="93310-104">Le modèle CQRS (Command and Query Responsibility Segregation, répartition des responsabilités entre les commandes et les requêtes) est un style d’architecture qui sépare les opérations de lecture des opérations d’écriture.</span><span class="sxs-lookup"><span data-stu-id="93310-104">Command and Query Responsibility Segregation (CQRS) is an architecture style that separates read operations from write operations.</span></span> 

![](./images/cqrs-logical.svg)

<span data-ttu-id="93310-105">Dans les architectures traditionnelles, le même modèle de données est utilisé pour interroger et mettre à jour une base de données.</span><span class="sxs-lookup"><span data-stu-id="93310-105">In traditional architectures, the same data model is used to query and update a database.</span></span> <span data-ttu-id="93310-106">Cette approche se révèle simple et efficace pour les opérations CRUD de base.</span><span class="sxs-lookup"><span data-stu-id="93310-106">That's simple and works well for basic CRUD operations.</span></span> <span data-ttu-id="93310-107">Toutefois, dans le cas des applications plus complexes, elle peut devenir plus difficile à gérer.</span><span class="sxs-lookup"><span data-stu-id="93310-107">In more complex applications, however, this approach can become unwieldy.</span></span> <span data-ttu-id="93310-108">Par exemple, côté lecture, l’application peut exécuter de nombreuses requêtes, renvoyant des objets de transfert de données de différentes formes.</span><span class="sxs-lookup"><span data-stu-id="93310-108">For example, on the read side, the application may perform many different queries, returning data transfer objects (DTOs) with different shapes.</span></span> <span data-ttu-id="93310-109">Le mappage d’objets peut alors devenir compliqué.</span><span class="sxs-lookup"><span data-stu-id="93310-109">Object mapping can become complicated.</span></span> <span data-ttu-id="93310-110">Côté écriture, le modèle peut implémenter une logique métier et de validation complexe.</span><span class="sxs-lookup"><span data-stu-id="93310-110">On the write side, the model may implement complex validation and business logic.</span></span> <span data-ttu-id="93310-111">Par conséquent, vous risquez d’obtenir un modèle excessivement complexe et surchargé.</span><span class="sxs-lookup"><span data-stu-id="93310-111">As a result, you can end up with an overly complex model that does too much.</span></span>

<span data-ttu-id="93310-112">Un autre problème potentiel réside dans le fait que les charges de travail de lecture et d’écriture sont souvent asymétriques et présentent des exigences de performances et de mise à l’échelle très différentes.</span><span class="sxs-lookup"><span data-stu-id="93310-112">Another potential problem is that read and write workloads are often asymmetrical, with very different performance and scale requirements.</span></span> 

<span data-ttu-id="93310-113">CQRS résout ces problèmes en séparant les lectures des écritures dans des modèles distincts et utilise des **commandes** pour mettre à jour les données, et des **requêtes** pour lire les données.</span><span class="sxs-lookup"><span data-stu-id="93310-113">CQRS addresses these problems by separating reads and writes into separate models, using **commands** to update data, and **queries** to read data.</span></span>

- <span data-ttu-id="93310-114">Les commandes doivent reposer sur les tâches au lieu d’être centrées sur les données</span><span class="sxs-lookup"><span data-stu-id="93310-114">Commands should be task based, rather than data centric.</span></span> <span data-ttu-id="93310-115">(par exemple, « Réserver une chambre d’hôtel » plutôt que « Définir l’état de réservation sur Réservé »). Les commandes peuvent être placées dans une file d’attente pour faire l’objet d’un traitement asynchrone, au lieu d’être traitées de manière synchrone.</span><span class="sxs-lookup"><span data-stu-id="93310-115">("Book hotel room," not "set ReservationStatus to Reserved.") Commands may be placed on a queue for asynchronous processing, rather than being processed synchronously.</span></span>

- <span data-ttu-id="93310-116">Les requêtes ne modifient jamais la base de données.</span><span class="sxs-lookup"><span data-stu-id="93310-116">Queries never modify the database.</span></span> <span data-ttu-id="93310-117">Une requête renvoie un objet de transfert de données qui n’encapsule aucune connaissance du domaine.</span><span class="sxs-lookup"><span data-stu-id="93310-117">A query returns a DTO that does not encapsulate any domain knowledge.</span></span>

<span data-ttu-id="93310-118">Pour renforcer l’isolation, vous pouvez séparer physiquement les données de lecture des données d’écriture.</span><span class="sxs-lookup"><span data-stu-id="93310-118">For greater isolation, you can physically separate the read data from the write data.</span></span> <span data-ttu-id="93310-119">Dans ce cas, la base de données de lecture peut utiliser son propre schéma de données optimisé pour les requêtes.</span><span class="sxs-lookup"><span data-stu-id="93310-119">In that case, the read database can use its own data schema that is optimized for queries.</span></span> <span data-ttu-id="93310-120">Par exemple, elle peut stocker une [vue matérialisée][materialized-view] des données, afin d’éviter des jointures ou des mappages O/RM complexes.</span><span class="sxs-lookup"><span data-stu-id="93310-120">For example, it can store a [materialized view][materialized-view] of the data, in order to avoid complex joins or complex O/RM mappings.</span></span> <span data-ttu-id="93310-121">Elle peut même utiliser un autre type de magasin de données.</span><span class="sxs-lookup"><span data-stu-id="93310-121">It might even use a different type of data store.</span></span> <span data-ttu-id="93310-122">Par exemple, il est possible que la base de données d’écriture soit relationnelle, et que la base de données de lecture soit une base de données de documents.</span><span class="sxs-lookup"><span data-stu-id="93310-122">For example, the write database might be relational, while the read database is a document database.</span></span>

<span data-ttu-id="93310-123">Si vous utilisez des bases de données de lecture et d’écriture distinctes, vous devez les garder synchronisées. En règle générale, vous obtenez ce résultat en faisant en sorte que le modèle d’écriture publie un événement chaque fois qu’il met à jour la base de données.</span><span class="sxs-lookup"><span data-stu-id="93310-123">If separate read and write databases are used, they must be kept in sync. Typically this is accomplished by  having the write model publish an event whenever it updates the database.</span></span> <span data-ttu-id="93310-124">La mise à jour de la base de données et la publication de l’événement doivent s’effectuer dans une transaction unique.</span><span class="sxs-lookup"><span data-stu-id="93310-124">Updating the database and publishing the event must occur in a single transaction.</span></span> 

<span data-ttu-id="93310-125">Certaines implémentations de l’architecture CQRS utilisent le [modèle d’approvisionnement en événements][event-sourcing] (ou Event Sourcing).</span><span class="sxs-lookup"><span data-stu-id="93310-125">Some implementations of CQRS use the [Event Sourcing pattern][event-sourcing].</span></span> <span data-ttu-id="93310-126">Avec ce modèle, l’état de l’application est stocké sous la forme d’une séquence d’événements.</span><span class="sxs-lookup"><span data-stu-id="93310-126">With this pattern, application state is stored as a sequence of events.</span></span> <span data-ttu-id="93310-127">Chaque événement représente un ensemble de modifications des données.</span><span class="sxs-lookup"><span data-stu-id="93310-127">Each event represents a set of changes to the data.</span></span> <span data-ttu-id="93310-128">L’état actuel est construit par la relecture des événements.</span><span class="sxs-lookup"><span data-stu-id="93310-128">The current state is constructed by replaying the events.</span></span> <span data-ttu-id="93310-129">Dans un contexte CQRS, l’un des avantages de l’approvisionnement en événements réside dans le fait que les mêmes événements peuvent être utilisés pour informer les autres composants &mdash; en particulier, pour avertir le modèle de lecture.</span><span class="sxs-lookup"><span data-stu-id="93310-129">In a CQRS context, one benefit of Event Sourcing is that the same events can be used to notify other components &mdash; in particular, to notify the read model.</span></span> <span data-ttu-id="93310-130">Le modèle de lecture utilise les événements pour créer une capture instantanée de l’état actuel, ce qui se révèle plus efficace pour les requêtes.</span><span class="sxs-lookup"><span data-stu-id="93310-130">The read model uses the events to create a snapshot of the current state, which is more efficient for queries.</span></span> <span data-ttu-id="93310-131">Toutefois, l’approvisionnement en événements complique la conception.</span><span class="sxs-lookup"><span data-stu-id="93310-131">However, Event Sourcing adds complexity to the design.</span></span>

![](./images/cqrs-events.svg)

## <a name="when-to-use-this-architecture"></a><span data-ttu-id="93310-132">Quand utiliser cette architecture</span><span class="sxs-lookup"><span data-stu-id="93310-132">When to use this architecture</span></span>

<span data-ttu-id="93310-133">Envisagez d’utiliser CQRS pour les domaines collaboratifs dans lesquels de nombreux utilisateurs accèdent aux mêmes données, en particulier lorsque les charges de travail de lecture et d’écriture sont asymétriques.</span><span class="sxs-lookup"><span data-stu-id="93310-133">Consider CQRS for collaborative domains where many users access the same data, especially when the read and write workloads are asymmetrical.</span></span>

<span data-ttu-id="93310-134">CQRS n’est pas une architecture de premier niveau qui s’applique à la totalité d’un système.</span><span class="sxs-lookup"><span data-stu-id="93310-134">CQRS is not a top-level architecture that applies to an entire system.</span></span> <span data-ttu-id="93310-135">Appliquez uniquement CQRS aux sous-systèmes dans lesquels la séparation des lectures et des écritures présente un intérêt manifeste.</span><span class="sxs-lookup"><span data-stu-id="93310-135">Apply CQRS only to those subsystems where there is clear value in separating reads and writes.</span></span> <span data-ttu-id="93310-136">Dans le cas contraire, vous ajouterez de la complexité sans recevoir aucun avantage en contrepartie.</span><span class="sxs-lookup"><span data-stu-id="93310-136">Otherwise, you are creating additional complexity for no benefit.</span></span>

## <a name="benefits"></a><span data-ttu-id="93310-137">Avantages</span><span class="sxs-lookup"><span data-stu-id="93310-137">Benefits</span></span>

- <span data-ttu-id="93310-138">**Mise à l’échelle de manière indépendante**.</span><span class="sxs-lookup"><span data-stu-id="93310-138">**Independently scaling**.</span></span> <span data-ttu-id="93310-139">CQRS permet de mettre à l’échelle les charges de travail de lecture et d’écriture indépendamment, et peut contribuer à réduire les contentions de verrouillage.</span><span class="sxs-lookup"><span data-stu-id="93310-139">CQRS allows the read and write workloads to scale independently, and may result in fewer lock contentions.</span></span>
- <span data-ttu-id="93310-140">**Schémas de données optimisés**.</span><span class="sxs-lookup"><span data-stu-id="93310-140">**Optimized data schemas.**</span></span>  <span data-ttu-id="93310-141">Le côté lecture peut utiliser un schéma optimisé pour les requêtes, tandis que le côté écriture utilise un schéma optimisé pour les mises à jour.</span><span class="sxs-lookup"><span data-stu-id="93310-141">The read side can use a schema that is optimized for queries, while the write side uses a schema that is optimized for updates.</span></span>  
- <span data-ttu-id="93310-142">**Sécurité**.</span><span class="sxs-lookup"><span data-stu-id="93310-142">**Security**.</span></span> <span data-ttu-id="93310-143">Il est plus facile de s’assurer que seules les entités de domaine adéquates effectuent des écritures sur les données.</span><span class="sxs-lookup"><span data-stu-id="93310-143">It's easier to ensure that only the right domain entities are performing writes on the data.</span></span>
- <span data-ttu-id="93310-144">**Séparation des problèmes**.</span><span class="sxs-lookup"><span data-stu-id="93310-144">**Separation of concerns**.</span></span> <span data-ttu-id="93310-145">Le fait de séparer le côté lecture du côté écriture peut produire des modèles plus faciles à gérer et plus flexibles.</span><span class="sxs-lookup"><span data-stu-id="93310-145">Segregating the read and write sides can result in models that are more maintainable and flexible.</span></span> <span data-ttu-id="93310-146">La plus grande partie de la logique métier complexe est placée dans le modèle d’écriture.</span><span class="sxs-lookup"><span data-stu-id="93310-146">Most of the complex business logic goes into the write model.</span></span> <span data-ttu-id="93310-147">Le modèle de lecture peut être relativement simple.</span><span class="sxs-lookup"><span data-stu-id="93310-147">The read model can be relatively simple.</span></span>
- <span data-ttu-id="93310-148">**Requêtes simplifiées**.</span><span class="sxs-lookup"><span data-stu-id="93310-148">**Simpler queries**.</span></span> <span data-ttu-id="93310-149">En stockant une vue matérialisée dans la base de données de lecture, l’application peut éviter les jointures complexes lors de l’interrogation.</span><span class="sxs-lookup"><span data-stu-id="93310-149">By storing a materialized view in the read database, the application can avoid complex joins when querying.</span></span>

## <a name="challenges"></a><span data-ttu-id="93310-150">Défis</span><span class="sxs-lookup"><span data-stu-id="93310-150">Challenges</span></span>

- <span data-ttu-id="93310-151">**Complexité** :</span><span class="sxs-lookup"><span data-stu-id="93310-151">**Complexity**.</span></span> <span data-ttu-id="93310-152">Le principe de base de CQRS est simple.</span><span class="sxs-lookup"><span data-stu-id="93310-152">The basic idea of CQRS is simple.</span></span> <span data-ttu-id="93310-153">Toutefois, cette architecture peut compliquer la conception d’applications, notamment si elle inclut le modèle d’approvisionnement en événements.</span><span class="sxs-lookup"><span data-stu-id="93310-153">But it can lead to a more complex application design, especially if they include the Event Sourcing pattern.</span></span>

- <span data-ttu-id="93310-154">**Messagerie**.</span><span class="sxs-lookup"><span data-stu-id="93310-154">**Messaging**.</span></span> <span data-ttu-id="93310-155">Bien que CQRS ne nécessite aucune messagerie, il est fréquent d’utiliser une messagerie pour traiter les commandes et pour publier les événements de mise à jour.</span><span class="sxs-lookup"><span data-stu-id="93310-155">Although CQRS does not require messaging, it's common to use messaging to process commands and publish update events.</span></span> <span data-ttu-id="93310-156">Dans ce cas, l’application doit gérer les échecs de messages ou les messages en double.</span><span class="sxs-lookup"><span data-stu-id="93310-156">In that case, the application must handle message failures or duplicate messages.</span></span> 

- <span data-ttu-id="93310-157">**Cohérence finale**.</span><span class="sxs-lookup"><span data-stu-id="93310-157">**Eventual consistency**.</span></span> <span data-ttu-id="93310-158">Si vous séparez les bases de données de lecture et d’écriture, les données de lecture peuvent être périmées.</span><span class="sxs-lookup"><span data-stu-id="93310-158">If you separate the read and write databases, the read data may be stale.</span></span> 

## <a name="best-practices"></a><span data-ttu-id="93310-159">Meilleures pratiques</span><span class="sxs-lookup"><span data-stu-id="93310-159">Best practices</span></span>

- <span data-ttu-id="93310-160">Pour plus d’informations sur l’implémentation de CQRS, consultez l’article [CQRS Pattern (Modèle CQRS)][cqrs-pattern].</span><span class="sxs-lookup"><span data-stu-id="93310-160">For more information about implementing CQRS, see [CQRS Pattern][cqrs-pattern].</span></span>

- <span data-ttu-id="93310-161">Envisagez d’utiliser le modèle [Approvisionnement en événements][event-sourcing] pour éviter les conflits de mise à jour.</span><span class="sxs-lookup"><span data-stu-id="93310-161">Consider using the [Event Sourcing][event-sourcing] pattern to avoid update conflicts.</span></span>

- <span data-ttu-id="93310-162">Pensez à utiliser le [modèle de vue matérialisée][materialized-view] pour le modèle de lecture afin d’optimiser le schéma pour les requêtes.</span><span class="sxs-lookup"><span data-stu-id="93310-162">Consider using the [Materialized View pattern][materialized-view] for the read model, to optimize the schema for queries.</span></span>

## <a name="cqrs-in-microservices"></a><span data-ttu-id="93310-163">CQRS dans les microservices</span><span class="sxs-lookup"><span data-stu-id="93310-163">CQRS in microservices</span></span>

<span data-ttu-id="93310-164">CQRS peut se révéler particulièrement utile dans une [architecture de microservices][microservices].</span><span class="sxs-lookup"><span data-stu-id="93310-164">CQRS can be especially useful in a [microservices architecture][microservices].</span></span> <span data-ttu-id="93310-165">L’un des principes des microservices est qu’un service ne peut pas accéder directement au magasin de données d’un autre service.</span><span class="sxs-lookup"><span data-stu-id="93310-165">One of the principles of microservices is that a service cannot directly access another service's data store.</span></span>

![](./images/cqrs-microservices-wrong.png)

<span data-ttu-id="93310-166">Dans le diagramme ci-après, le Service A écrit dans un magasin de données, et le Service B conserve une vue matérialisée des données.</span><span class="sxs-lookup"><span data-stu-id="93310-166">In the following diagram, Service A writes to a data store, and Service B keeps a materialized view of the data.</span></span> <span data-ttu-id="93310-167">Le Service A publie un événement chaque fois qu’il écrit dans le magasin de données.</span><span class="sxs-lookup"><span data-stu-id="93310-167">Service A publishes an event whenever it writes to the data store.</span></span> <span data-ttu-id="93310-168">Le Service B s’abonne à l’événement.</span><span class="sxs-lookup"><span data-stu-id="93310-168">Service B subscribes to the event.</span></span>

![](./images/cqrs-microservices-right.png)


<!-- links -->

[cqrs-pattern]: ../../patterns/cqrs.md
[event-sourcing]: ../../patterns/event-sourcing.md
[materialized-view]: ../../patterns/materialized-view.md
[microservices]: ./microservices.md
