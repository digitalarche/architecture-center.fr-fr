---
title: Communication interservice dans les microservices
description: Communication interservice dans les microservices
author: MikeWasson
ms.date: 10/23/2018
ms.openlocfilehash: 19a54ffc362a1fc88c3255c9346bd697a319b143
ms.sourcegitcommit: fdcacbfdc77370532a4dde776c5d9b82227dff2d
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 10/24/2018
ms.locfileid: "49962957"
---
# <a name="designing-microservices-interservice-communication"></a><span data-ttu-id="8eef2-103">Conception de microservices : communication interservice</span><span class="sxs-lookup"><span data-stu-id="8eef2-103">Designing microservices: Interservice communication</span></span>

<span data-ttu-id="8eef2-104">La communication entre les microservices doit se révéler à la fois efficace et robuste.</span><span class="sxs-lookup"><span data-stu-id="8eef2-104">Communication between microservices must be efficient and robust.</span></span> <span data-ttu-id="8eef2-105">Or, étant donné que l’exécution d’une simple transaction implique l’interaction d’un grand nombre de petits services, cet objectif peut représenter un véritable défi.</span><span class="sxs-lookup"><span data-stu-id="8eef2-105">With lots of small services interacting to complete a single transaction, this can be a challenge.</span></span> <span data-ttu-id="8eef2-106">Dans cet article, nous allons comparer les compromis induits par l’utilisation d’une messagerie asynchrone et par l’emploi d’API synchrones.</span><span class="sxs-lookup"><span data-stu-id="8eef2-106">In this chapter, we look at the tradeoffs between asynchronous messaging versus synchronous APIs.</span></span> <span data-ttu-id="8eef2-107">Ensuite, nous étudierons certaines des difficultés liées à la conception de communications interservice résilientes, ainsi que le rôle qu’une maille de services peut jouer.</span><span class="sxs-lookup"><span data-stu-id="8eef2-107">Then we look at some of the challenges in designing resilient interservice communication, and the role that a service mesh can play.</span></span>

![](./images/interservice-communication.png)

## <a name="challenges"></a><span data-ttu-id="8eef2-108">Défis</span><span class="sxs-lookup"><span data-stu-id="8eef2-108">Challenges</span></span> 

<span data-ttu-id="8eef2-109">Cette section répertorie quelques-uns des principaux défis en matière de communications interservice.</span><span class="sxs-lookup"><span data-stu-id="8eef2-109">Here are some of the main challenges arising from service-to-service communication.</span></span> <span data-ttu-id="8eef2-110">Les mailles de services, décrites plus loin dans cet article, sont conçues pour vous aider à relever la plupart de ces défis.</span><span class="sxs-lookup"><span data-stu-id="8eef2-110">Service meshes, described later in this chapter, are designed to handle many of these challenges.</span></span>

<span data-ttu-id="8eef2-111">**Résilience**.</span><span class="sxs-lookup"><span data-stu-id="8eef2-111">**Resiliency.**</span></span> <span data-ttu-id="8eef2-112">Il peut exister plusieurs dizaines ou même centaines d’instances d’un microservice donné.</span><span class="sxs-lookup"><span data-stu-id="8eef2-112">There may be dozens or even hundreds of instances of any given microservice.</span></span> <span data-ttu-id="8eef2-113">Une instance peut échouer pour plusieurs raisons.</span><span class="sxs-lookup"><span data-stu-id="8eef2-113">An instance can fail for any number of reasons.</span></span> <span data-ttu-id="8eef2-114">Il peut se produire un échec au niveau du nœud, par exemple une défaillance matérielle ou un redémarrage de machine virtuelle.</span><span class="sxs-lookup"><span data-stu-id="8eef2-114">There can be a node-level failure, such as a hardware failure or a VM reboot.</span></span> <span data-ttu-id="8eef2-115">Une instance peut se bloquer ou être submergée de requêtes et se trouver dans l’incapacité de traiter toute nouvelle requête.</span><span class="sxs-lookup"><span data-stu-id="8eef2-115">An instance might crash, or be overwhelmed with requests and unable to process any new requests.</span></span> <span data-ttu-id="8eef2-116">Tous ces événements sont susceptibles d’entraîner l’échec d’un appel réseau.</span><span class="sxs-lookup"><span data-stu-id="8eef2-116">Any of these events can cause a network call to fail.</span></span> <span data-ttu-id="8eef2-117">Deux modèles de conception peuvent vous aider à accroître la résilience des appels réseau interservice :</span><span class="sxs-lookup"><span data-stu-id="8eef2-117">There are two design patterns that can help make service-to-service network calls more resilient:</span></span>

- <span data-ttu-id="8eef2-118">**[Nouvelle tentative](../patterns/retry.md)**.</span><span class="sxs-lookup"><span data-stu-id="8eef2-118">**[Retry](../patterns/retry.md)**.</span></span> <span data-ttu-id="8eef2-119">Un appel réseau peut échouer en raison d’une erreur temporaire qui disparaît d’elle-même.</span><span class="sxs-lookup"><span data-stu-id="8eef2-119">A network call may fail because of a transient fault that goes away by itself.</span></span> <span data-ttu-id="8eef2-120">Au lieu que l’opération échoue immédiatement, l’appelant doit généralement effectuer un nombre défini de nouvelles tentatives ou jusqu’à ce qu’un délai d’expiration configuré soit écoulé.</span><span class="sxs-lookup"><span data-stu-id="8eef2-120">Rather than fail outright, the caller should typically retry the operation a certain number of times, or until a configured time-out period elapses.</span></span> <span data-ttu-id="8eef2-121">Toutefois, si une opération n’est pas idempotente, les nouvelles tentatives peuvent produire des effets secondaires imprévus.</span><span class="sxs-lookup"><span data-stu-id="8eef2-121">However, if an operation is not idempotent, retries can cause unintended side effects.</span></span> <span data-ttu-id="8eef2-122">Ainsi, il est possible que l’appel d’origine réussisse, mais que l’appelant n’obtienne jamais de réponse.</span><span class="sxs-lookup"><span data-stu-id="8eef2-122">The original call might succeed, but the caller never gets a response.</span></span> <span data-ttu-id="8eef2-123">Si l’appelant effectue une nouvelle tentative, l’opération risque d’être appelée deux fois.</span><span class="sxs-lookup"><span data-stu-id="8eef2-123">If the caller retries, the operation may be invoked twice.</span></span> <span data-ttu-id="8eef2-124">En règle générale, il est déconseillé de retenter l’exécution des méthodes POST ou PATCH, car le caractère idempotent de ces dernières n’est pas garanti.</span><span class="sxs-lookup"><span data-stu-id="8eef2-124">Generally, it's not safe to retry POST or PATCH methods, because these are not guaranteed to be idempotent.</span></span>

- <span data-ttu-id="8eef2-125">**[Disjoncteur](../patterns/circuit-breaker.md)**.</span><span class="sxs-lookup"><span data-stu-id="8eef2-125">**[Circuit Breaker](../patterns/circuit-breaker.md)**.</span></span> <span data-ttu-id="8eef2-126">Un nombre excessif de requêtes ayant échoué peut provoquer un goulot d’étranglement, car les requêtes en attente s’accumulent dans la file d’attente.</span><span class="sxs-lookup"><span data-stu-id="8eef2-126">Too many failed requests can cause a bottleneck, as pending requests accumulate in the queue.</span></span> <span data-ttu-id="8eef2-127">Ces demandes bloquées peuvent contenir des ressources système critiques telles que la mémoire, des threads, les connexions de la base de données, etc. Cela peut provoquer une succession d’échecs.</span><span class="sxs-lookup"><span data-stu-id="8eef2-127">These blocked requests might hold critical system resources such as memory, threads, database connections, and so on, which can cause cascading failures.</span></span> <span data-ttu-id="8eef2-128">Le modèle Disjoncteur peut empêcher un service de tenter d’exécuter à plusieurs reprises une opération susceptible d’échouer.</span><span class="sxs-lookup"><span data-stu-id="8eef2-128">The Circuit Breaker pattern can prevent a service from repeatedly trying an operation that is likely to fail.</span></span> 

<span data-ttu-id="8eef2-129">**Équilibrage de charge**.</span><span class="sxs-lookup"><span data-stu-id="8eef2-129">**Load balancing**.</span></span> <span data-ttu-id="8eef2-130">Lorsque le service « A » appelle le service « B », la requête doit atteindre une instance en cours d’exécution du service « B ».</span><span class="sxs-lookup"><span data-stu-id="8eef2-130">When service "A" calls service "B", the request must reach a running instance of service "B".</span></span> <span data-ttu-id="8eef2-131">Dans Kubernetes, le type de ressource `Service` fournit une adresse IP stable pour un groupe de pods.</span><span class="sxs-lookup"><span data-stu-id="8eef2-131">In Kubernetes, the `Service` resource type provides a stable IP address for a group of pods.</span></span> <span data-ttu-id="8eef2-132">Le trafic réseau vers l’adresse IP du service est transféré à un pod au moyen de règles d’iptable.</span><span class="sxs-lookup"><span data-stu-id="8eef2-132">Network traffic to the service's IP address gets forwarded to a pod by means of iptable rules.</span></span> <span data-ttu-id="8eef2-133">Par défaut, un pod aléatoire est choisi.</span><span class="sxs-lookup"><span data-stu-id="8eef2-133">By default, a random pod is chosen.</span></span> <span data-ttu-id="8eef2-134">Une maille de services (voir ci-dessous) peut fournir des algorithmes d’équilibrage de charge plus intelligents en fonction de la latence observée ou d’autres mesures.</span><span class="sxs-lookup"><span data-stu-id="8eef2-134">A service mesh (see below) can provide more intelligent load balancing algorithms based on observed latency or other metrics.</span></span>

<span data-ttu-id="8eef2-135">**Traçage distribué**.</span><span class="sxs-lookup"><span data-stu-id="8eef2-135">**Distributed tracing**.</span></span> <span data-ttu-id="8eef2-136">Une même transaction peut s’étendre sur plusieurs services.</span><span class="sxs-lookup"><span data-stu-id="8eef2-136">A single transaction may span multiple services.</span></span> <span data-ttu-id="8eef2-137">Cette situation peut compliquer la surveillance des performances globales et de l’intégrité du système.</span><span class="sxs-lookup"><span data-stu-id="8eef2-137">That can make it hard to monitor the overall performance and health of the system.</span></span> <span data-ttu-id="8eef2-138">Même si chaque service génère des journaux et des mesures, ces informations seront d’une utilité limitée si elles ne sont pas liées d’une manière ou d’une autre.</span><span class="sxs-lookup"><span data-stu-id="8eef2-138">Even if every service generates logs and metrics, without some way to tie them together, they are of limited use.</span></span> <span data-ttu-id="8eef2-139">Le traçage distribué constitue donc un défi à relever et est décrit de façon plus détaillée dans l’article [Journalisation et surveillance](./logging-monitoring.md).</span><span class="sxs-lookup"><span data-stu-id="8eef2-139">The chapter [Logging and monitoring](./logging-monitoring.md) talks more about distributed tracing, but we mention it here as a challenge.</span></span>

<span data-ttu-id="8eef2-140">**Contrôle de version des services**.</span><span class="sxs-lookup"><span data-stu-id="8eef2-140">**Service versioning**.</span></span> <span data-ttu-id="8eef2-141">Lorsqu’une équipe déploie une nouvelle version d’un service, elle doit éviter d’interrompre tout autre service ou les clients externes qui dépendent de ce service.</span><span class="sxs-lookup"><span data-stu-id="8eef2-141">When a team deploys a new version of a service, they must avoid breaking any other services or external clients that depend on it.</span></span> <span data-ttu-id="8eef2-142">En outre, vous pouvez vouloir exécuter plusieurs versions d’un service côte à côte et acheminer les requêtes vers une version spécifique.</span><span class="sxs-lookup"><span data-stu-id="8eef2-142">In addition, you might want to run multiple versions of a service side-by-side, and route requests to a particular version.</span></span> <span data-ttu-id="8eef2-143">Pour plus d’informations sur cet aspect, consultez la section [Contrôle de version d’API](./api-design.md#api-versioning).</span><span class="sxs-lookup"><span data-stu-id="8eef2-143">See [API Versioning](./api-design.md#api-versioning) for more discussion of this issue.</span></span>

<span data-ttu-id="8eef2-144">**Chiffrement TLS et authentification TLS mutuelle**.</span><span class="sxs-lookup"><span data-stu-id="8eef2-144">**TLS encryption and mutual TLS authentication**.</span></span> <span data-ttu-id="8eef2-145">Pour des raisons de sécurité, vous pouvez chiffrer le trafic entre les services avec TLS et utiliser l’authentification TLS mutuelle pour authentifier les appelants.</span><span class="sxs-lookup"><span data-stu-id="8eef2-145">For security reasons, you may want to encrypt traffic between services with TLS, and use mutual TLS authentication to authenticate callers.</span></span>

## <a name="synchronous-versus-asynchronous-messaging"></a><span data-ttu-id="8eef2-146">Comparaison entre messagerie synchrone et messagerie asynchrone</span><span class="sxs-lookup"><span data-stu-id="8eef2-146">Synchronous versus asynchronous messaging</span></span>

<span data-ttu-id="8eef2-147">Les microservices peuvent utiliser deux modèles de messagerie de base pour communiquer avec d’autres microservices.</span><span class="sxs-lookup"><span data-stu-id="8eef2-147">There are two basic messaging patterns that microservices can use to communicate with other microservices.</span></span> 

1. <span data-ttu-id="8eef2-148">Communication synchrone.</span><span class="sxs-lookup"><span data-stu-id="8eef2-148">Synchronous communication.</span></span> <span data-ttu-id="8eef2-149">Dans ce modèle, un service appelle une API exposée par un autre service à l’aide d’un protocole tel que HTTP ou gRPC.</span><span class="sxs-lookup"><span data-stu-id="8eef2-149">In this pattern, a service calls an API that another service exposes, using a protocol such as HTTP or gRPC.</span></span> <span data-ttu-id="8eef2-150">Cette option constitue un modèle de messagerie synchrone, car l’appelant attend une réponse de la part du récepteur.</span><span class="sxs-lookup"><span data-stu-id="8eef2-150">This option is a synchronous messaging pattern because the caller waits for a response from the receiver.</span></span> 

2. <span data-ttu-id="8eef2-151">Transmission de message asynchrone.</span><span class="sxs-lookup"><span data-stu-id="8eef2-151">Asynchronous message passing.</span></span> <span data-ttu-id="8eef2-152">Dans ce modèle, un service envoie un message sans attendre de réponse, et un ou plusieurs services traitent ce message de façon asynchrone.</span><span class="sxs-lookup"><span data-stu-id="8eef2-152">In this pattern, a service sends message without waiting for a response, and one or more services process the message asynchronously.</span></span>

<span data-ttu-id="8eef2-153">Il est important d’établir une distinction entre E/S asynchrone et protocole asynchrone.</span><span class="sxs-lookup"><span data-stu-id="8eef2-153">It's important to distinguish between asynchronous I/O and an asynchronous protocol.</span></span> <span data-ttu-id="8eef2-154">Le terme E/S asynchrone signifie que le thread appelant n’est pas bloqué pendant que l’E/S s’exécute.</span><span class="sxs-lookup"><span data-stu-id="8eef2-154">Asynchronous I/O means the calling thread is not blocked while the I/O completes.</span></span> <span data-ttu-id="8eef2-155">Cette approche est importante pour les performances, mais constitue un détail d’implémentation en termes d’architecture.</span><span class="sxs-lookup"><span data-stu-id="8eef2-155">That's important for performance, but is an implementation detail in terms of the architecture.</span></span> <span data-ttu-id="8eef2-156">Un protocole asynchrone signifie que l’expéditeur n’attend pas de réponse.</span><span class="sxs-lookup"><span data-stu-id="8eef2-156">An asynchronous protocol means the sender doesn't wait for a response.</span></span> <span data-ttu-id="8eef2-157">HTTP est un protocole synchrone, même si un client HTTP peut utiliser des E/S asynchrones lorsqu’il envoie une requête.</span><span class="sxs-lookup"><span data-stu-id="8eef2-157">HTTP is a synchronous protocol, even though an HTTP client may use asynchronous I/O when it sends a request.</span></span> 

<span data-ttu-id="8eef2-158">Chaque modèle implique des compromis.</span><span class="sxs-lookup"><span data-stu-id="8eef2-158">There are tradeoffs to each pattern.</span></span> <span data-ttu-id="8eef2-159">Le modèle requête/réponse constitue un paradigme bien défini, de sorte que la conception d’une API peut sembler plus naturelle que celle d’un système de messagerie.</span><span class="sxs-lookup"><span data-stu-id="8eef2-159">Request/response is a well-understood paradigm, so designing an API may feel more natural than designing a messaging system.</span></span> <span data-ttu-id="8eef2-160">Toutefois, la messagerie asynchrone confère certains avantages qui peuvent se révéler d’une grande utilité dans une architecture de microservices :</span><span class="sxs-lookup"><span data-stu-id="8eef2-160">However, asynchronous messaging has some advantages that can be very useful in a microservices architecture:</span></span>

- <span data-ttu-id="8eef2-161">**Couplage réduit**.</span><span class="sxs-lookup"><span data-stu-id="8eef2-161">**Reduced coupling**.</span></span> <span data-ttu-id="8eef2-162">L’expéditeur du message n’a pas besoin de disposer d’informations concernant le consommateur.</span><span class="sxs-lookup"><span data-stu-id="8eef2-162">The message sender does not need to know about the consumer.</span></span> 

- <span data-ttu-id="8eef2-163">**Abonnés multiples**.</span><span class="sxs-lookup"><span data-stu-id="8eef2-163">**Multiple subscribers**.</span></span> <span data-ttu-id="8eef2-164">Un modèle de publication/abonnement permet à plusieurs consommateurs de s’abonner à la réception d’événements.</span><span class="sxs-lookup"><span data-stu-id="8eef2-164">Using a pub/sub model, multiple consumers can subscribe to receive events.</span></span> <span data-ttu-id="8eef2-165">Consultez l’article [Style d’architecture basée sur les événements](/azure/architecture/guide/architecture-styles/event-driven).</span><span class="sxs-lookup"><span data-stu-id="8eef2-165">See [Event-driven architecture style](/azure/architecture/guide/architecture-styles/event-driven).</span></span>

- <span data-ttu-id="8eef2-166">**Isolation des défaillances**.</span><span class="sxs-lookup"><span data-stu-id="8eef2-166">**Failure isolation**.</span></span> <span data-ttu-id="8eef2-167">Si le consommateur échoue, l’expéditeur peut toujours envoyer des messages.</span><span class="sxs-lookup"><span data-stu-id="8eef2-167">If the consumer fails, the sender can still send messages.</span></span> <span data-ttu-id="8eef2-168">Ces messages seront récupérés une fois que l’état normal du consommateur aura été rétabli.</span><span class="sxs-lookup"><span data-stu-id="8eef2-168">The messages will be picked up when the consumer recovers.</span></span> <span data-ttu-id="8eef2-169">Cette possibilité se révèle particulièrement utile dans une architecture de microservices, car chaque service possède son propre cycle de vie.</span><span class="sxs-lookup"><span data-stu-id="8eef2-169">This ability is especially useful in a microservices architecture, because each service has its own lifecycle.</span></span> <span data-ttu-id="8eef2-170">Il est possible qu’un service devienne inaccessible ou soit remplacé par une version plus récente à un moment donné.</span><span class="sxs-lookup"><span data-stu-id="8eef2-170">A service could become unavailable or be replaced with a newer version at any given time.</span></span> <span data-ttu-id="8eef2-171">Une messagerie asynchrone peut gérer les temps d’arrêt intermittents.</span><span class="sxs-lookup"><span data-stu-id="8eef2-171">Asynchronous messaging can handle intermittent downtime.</span></span> <span data-ttu-id="8eef2-172">En revanche, les API synchrones exigent que le service en aval soit disponible ; dans le cas contraire, l’opération échouera.</span><span class="sxs-lookup"><span data-stu-id="8eef2-172">Synchronous APIs, on the other hand, require the downstream service to be available or the operation fails.</span></span> 
 
- <span data-ttu-id="8eef2-173">**Réactivité**.</span><span class="sxs-lookup"><span data-stu-id="8eef2-173">**Responsiveness**.</span></span> <span data-ttu-id="8eef2-174">Un service en amont peut répondre plus rapidement s’il n’attend aucune réaction de la part des services en aval.</span><span class="sxs-lookup"><span data-stu-id="8eef2-174">An upstream service can reply faster if it does not wait on downstream services.</span></span> <span data-ttu-id="8eef2-175">Cette approche se révèle particulièrement utile dans une architecture de microservices.</span><span class="sxs-lookup"><span data-stu-id="8eef2-175">This is especially useful in a microservices architecture.</span></span> <span data-ttu-id="8eef2-176">S’il existe une chaîne de dépendances entre les services (le service A appelle B, qui appelle C, et ainsi de suite), le temps d’attente inhérent aux appels synchrones risque d’augmenter la latence de manière inacceptable.</span><span class="sxs-lookup"><span data-stu-id="8eef2-176">If there is a chain of service dependencies (service A calls B, which calls C, and so on), waiting on synchronous calls can add unacceptable amounts of latency.</span></span>

- <span data-ttu-id="8eef2-177">**Nivellement de charge**.</span><span class="sxs-lookup"><span data-stu-id="8eef2-177">**Load leveling**.</span></span> <span data-ttu-id="8eef2-178">Une file d’attente peut jouer le rôle de mémoire tampon pour niveler la charge de travail, afin que les récepteurs puissent traiter les messages à leur propre rythme.</span><span class="sxs-lookup"><span data-stu-id="8eef2-178">A queue can act as a buffer to level the workload, so that receivers can process messages at their own rate.</span></span> 

- <span data-ttu-id="8eef2-179">**Workflows**.</span><span class="sxs-lookup"><span data-stu-id="8eef2-179">**Workflows**.</span></span> <span data-ttu-id="8eef2-180">Il est possible de gérer un workflow à l’aide de files d’attente en créant des points de contrôle qui vérifient le message après chaque étape du workflow.</span><span class="sxs-lookup"><span data-stu-id="8eef2-180">Queues can be used to manage a workflow, by check-pointing the message after each step in the workflow.</span></span>

<span data-ttu-id="8eef2-181">Toutefois, l’utilisation efficace d’une messagerie asynchrone soulève également certaines difficultés.</span><span class="sxs-lookup"><span data-stu-id="8eef2-181">However, there are also some challenges to using asynchronous messaging effectively.</span></span>

- <span data-ttu-id="8eef2-182">**Couplage avec l’infrastructure de messagerie**.</span><span class="sxs-lookup"><span data-stu-id="8eef2-182">**Coupling with the messaging infrastructure**.</span></span> <span data-ttu-id="8eef2-183">L’utilisation d’une infrastructure de messagerie spécifique risque d’entraîner un couplage étroit avec cette infrastructure.</span><span class="sxs-lookup"><span data-stu-id="8eef2-183">Using a particular messaging infrastructure may cause tight coupling with that infrastructure.</span></span> <span data-ttu-id="8eef2-184">Il sera alors difficile de passer à une autre infrastructure de messagerie par la suite.</span><span class="sxs-lookup"><span data-stu-id="8eef2-184">It will be difficult to switch to another messaging infrastructure later.</span></span>

- <span data-ttu-id="8eef2-185">**Latence**.</span><span class="sxs-lookup"><span data-stu-id="8eef2-185">**Latency**.</span></span> <span data-ttu-id="8eef2-186">La latence de bout en bout d’une opération peut devenir élevée si les files d’attente de messages deviennent saturées.</span><span class="sxs-lookup"><span data-stu-id="8eef2-186">End-to-end latency for an operation may become high if the message queues fill up.</span></span>  

- <span data-ttu-id="8eef2-187">**Coût**.</span><span class="sxs-lookup"><span data-stu-id="8eef2-187">**Cost**.</span></span> <span data-ttu-id="8eef2-188">L’utilisation de hauts débits est susceptible d’augmenter le coût monétaire de l’infrastructure de messagerie de façon significative.</span><span class="sxs-lookup"><span data-stu-id="8eef2-188">At high throughputs, the monetary cost of the messaging infrastructure could be significant.</span></span>

- <span data-ttu-id="8eef2-189">**Complexité** :</span><span class="sxs-lookup"><span data-stu-id="8eef2-189">**Complexity**.</span></span> <span data-ttu-id="8eef2-190">La gestion d’une messagerie asynchrone n’est pas une tâche aisée.</span><span class="sxs-lookup"><span data-stu-id="8eef2-190">Handling asynchronous messaging is not a trivial task.</span></span> <span data-ttu-id="8eef2-191">Par exemple, vous devez gérer les messages en double, soit en procédant à une déduplication, soit en rendant les opérations idempotentes.</span><span class="sxs-lookup"><span data-stu-id="8eef2-191">For example, you must handle duplicated messages, either by de-duplicating or by making operations idempotent.</span></span> <span data-ttu-id="8eef2-192">Il est également difficile d’implémenter la sémantique requête-réponse à l’aide d’une messagerie asynchrone.</span><span class="sxs-lookup"><span data-stu-id="8eef2-192">It's also hard to implement request-response semantics using asynchronous messaging.</span></span> <span data-ttu-id="8eef2-193">Pour envoyer une réponse, vous devez disposer d’une autre file d’attente, ainsi que d’un moyen de mettre en corrélation les messages de requête et de réponse.</span><span class="sxs-lookup"><span data-stu-id="8eef2-193">To send a response, you need another queue, plus a way to correlate request and response messages.</span></span>

- <span data-ttu-id="8eef2-194">**Débit**.</span><span class="sxs-lookup"><span data-stu-id="8eef2-194">**Throughput**.</span></span> <span data-ttu-id="8eef2-195">Si les messages nécessitent une *sémantique de file d’attente*, la file d’attente peut devenir un goulot d’étranglement dans le système.</span><span class="sxs-lookup"><span data-stu-id="8eef2-195">If messages require *queue semantics*, the queue can become a bottleneck in the system.</span></span> <span data-ttu-id="8eef2-196">Chaque message requiert au moins une opération de file d’attente et une opération d’enlèvement de la file d’attente.</span><span class="sxs-lookup"><span data-stu-id="8eef2-196">Each message requires at least one queue operation and one dequeue operation.</span></span> <span data-ttu-id="8eef2-197">En outre, la sémantique de file d’attente requiert généralement un certain type de verrouillage au sein de l’infrastructure de messagerie.</span><span class="sxs-lookup"><span data-stu-id="8eef2-197">Moreover, queue semantics generally require some kind of locking inside the messaging infrastructure.</span></span> <span data-ttu-id="8eef2-198">Si la file d’attente est un service géré, elle risque d’entraîner une latence supplémentaire, car la file d’attente est externe au réseau virtuel du cluster.</span><span class="sxs-lookup"><span data-stu-id="8eef2-198">If the queue is a managed service, there may be additional latency, because the queue is external to the cluster's virtual network.</span></span> <span data-ttu-id="8eef2-199">Vous pouvez atténuer ces problèmes en traitant les messages par lot, mais cette approche complique le code.</span><span class="sxs-lookup"><span data-stu-id="8eef2-199">You can mitigate these issues by batching messages, but that complicates the code.</span></span> <span data-ttu-id="8eef2-200">Si les messages ne nécessitent pas une sémantique de file d’attente, vous serez peut-être en mesure d’utiliser un *flux* d’événements plutôt qu’une file d’attente.</span><span class="sxs-lookup"><span data-stu-id="8eef2-200">If the messages don't require queue semantics, you might be able to use an event *stream* instead of a queue.</span></span> <span data-ttu-id="8eef2-201">Pour plus d’informations, consultez l’article [Style d’architecture basée sur les événements](../guide/architecture-styles/event-driven.md).</span><span class="sxs-lookup"><span data-stu-id="8eef2-201">For more information, see [Event-driven architectural style](../guide/architecture-styles/event-driven.md).</span></span>  

## <a name="drone-delivery-choosing-the-messaging-patterns"></a><span data-ttu-id="8eef2-202">Drone Delivery : choix des modèles de messagerie</span><span class="sxs-lookup"><span data-stu-id="8eef2-202">Drone Delivery: Choosing the messaging patterns</span></span>

<span data-ttu-id="8eef2-203">En tenant compte de ces considérations, l’équipe de développement a effectué les choix de conception ci-après pour l’application de livraison par drone Drone Delivery.</span><span class="sxs-lookup"><span data-stu-id="8eef2-203">With these considerations in mind, the development team made the following design choices for the Drone Delivery application</span></span>

- <span data-ttu-id="8eef2-204">Le service Ingestion expose une API REST publique que les applications clientes utilisent pour planifier, mettre à jour ou annuler les livraisons.</span><span class="sxs-lookup"><span data-stu-id="8eef2-204">The Ingestion service exposes a public REST API that client applications use to schedule, update, or cancel deliveries.</span></span>

- <span data-ttu-id="8eef2-205">Le service Ingestion utilise Event Hubs pour envoyer des messages asynchrones au service Scheduler.</span><span class="sxs-lookup"><span data-stu-id="8eef2-205">The Ingestion service uses Event Hubs to send asynchronous messages to the Scheduler service.</span></span> <span data-ttu-id="8eef2-206">Les messages asynchrones sont nécessaires à l’implémentation du nivellement de charge requis pour l’ingestion.</span><span class="sxs-lookup"><span data-stu-id="8eef2-206">Asynchronous messages are necessary to implement the load-leveling that is required for ingestion.</span></span> <span data-ttu-id="8eef2-207">Pour plus d’informations sur la façon dont les services Ingestion et Scheduler interagissent, consultez l’article [Ingestion et workflow][ingestion-workflow].</span><span class="sxs-lookup"><span data-stu-id="8eef2-207">For details on how the Ingestion and Scheduler services interact, see [Ingestion and workflow][ingestion-workflow].</span></span>

- <span data-ttu-id="8eef2-208">Les services Account, Delivery, Package, Drone et Third-party Transport exposent tous des API REST internes.</span><span class="sxs-lookup"><span data-stu-id="8eef2-208">The Account, Delivery, Package, Drone, and Third-party Transport services all expose internal REST APIs.</span></span> <span data-ttu-id="8eef2-209">Le service Scheduler appelle ces API pour effectuer une requête utilisateur.</span><span class="sxs-lookup"><span data-stu-id="8eef2-209">The Scheduler service calls these APIs to carry out a user request.</span></span> <span data-ttu-id="8eef2-210">L’utilisation d’API synchrones est notamment motivée par le fait que le service Scheduler a besoin d’obtenir une réponse de la part de chacun des services en aval.</span><span class="sxs-lookup"><span data-stu-id="8eef2-210">One reason to use synchronous APIs is that the Scheduler needs to get a response from each of the downstream services.</span></span> <span data-ttu-id="8eef2-211">Un échec dans l’un des services en aval signifie que la totalité de l’opération a échoué.</span><span class="sxs-lookup"><span data-stu-id="8eef2-211">A failure in any of the downstream services means the entire operation failed.</span></span> <span data-ttu-id="8eef2-212">Toutefois, le temps de latence introduit par l’appel des services principaux constitue un problème potentiel.</span><span class="sxs-lookup"><span data-stu-id="8eef2-212">However, a potential issue is the amount of latency that is introduced by calling the backend services.</span></span> 

- <span data-ttu-id="8eef2-213">Si l’un des services en aval présente un échec non temporaire, la totalité de la transaction doit être marquée comme ayant échoué.</span><span class="sxs-lookup"><span data-stu-id="8eef2-213">If any downstream service has a non-transient failure, the entire transaction should be marked as failed.</span></span> <span data-ttu-id="8eef2-214">Pour gérer cette situation, le service Scheduler envoie un message asynchrone au service Supervisor pour permettre à ce dernier de planifier les transactions de compensation, comme décrit dans l’article [Ingestion et workflow][ingestion-workflow].</span><span class="sxs-lookup"><span data-stu-id="8eef2-214">To handle this case, the Scheduler service sends an asynchronous message to the Supervisor, so that the Supervisor can schedule compensating transactions, as described in the chapter [Ingestion and workflow][ingestion-workflow].</span></span>   

- <span data-ttu-id="8eef2-215">Le service Delivery expose une API publique que les clients peuvent utiliser pour obtenir l’état d’une livraison.</span><span class="sxs-lookup"><span data-stu-id="8eef2-215">The Delivery service exposes a public API that clients can use to get the status of a delivery.</span></span> <span data-ttu-id="8eef2-216">Dans l’article [Passerelles d’API](./gateway.md), nous décrivons la façon dont une passerelle d’API peut masquer les services sous-jacents au client, afin que ce dernier n’ait pas besoin de savoir quelles sont les API exposées par les différents services.</span><span class="sxs-lookup"><span data-stu-id="8eef2-216">In the chapter [API gateway](./gateway.md), we discuss how an API gateway can hide the underlying services from the client, so the client doesn't need to know which services expose which APIs.</span></span> 

- <span data-ttu-id="8eef2-217">Lorsqu’un drone est en vol, le service Drone envoie des événements qui contiennent l’emplacement et l’état actuels du drone.</span><span class="sxs-lookup"><span data-stu-id="8eef2-217">While a drone is in flight, the Drone service sends events that contain the drone's current location and status.</span></span> <span data-ttu-id="8eef2-218">Le service Delivery écoute ces événements afin de suivre l’état d’une livraison.</span><span class="sxs-lookup"><span data-stu-id="8eef2-218">The Delivery service listens to these events in order to track the status of a delivery.</span></span>

- <span data-ttu-id="8eef2-219">Lorsque l’état d’une livraison change, le service Delivery envoie un événement d’état de livraison, tel que `DeliveryCreated` ou `DeliveryCompleted`.</span><span class="sxs-lookup"><span data-stu-id="8eef2-219">When the status of a delivery changes, the Delivery service sends a delivery status event, such as `DeliveryCreated` or `DeliveryCompleted`.</span></span> <span data-ttu-id="8eef2-220">Tous les services peuvent s’abonner à ces événements.</span><span class="sxs-lookup"><span data-stu-id="8eef2-220">Any service can subscribe to these events.</span></span> <span data-ttu-id="8eef2-221">Dans la conception actuelle, le service Delivery est le seul abonné, mais il pourra y avoir d’autres abonnés par la suite.</span><span class="sxs-lookup"><span data-stu-id="8eef2-221">In the current design, the Delivery service is the only subscriber, but there might be other subscribers later.</span></span> <span data-ttu-id="8eef2-222">Par exemple, les événements peuvent transiter par un service d’analyse en temps réel.</span><span class="sxs-lookup"><span data-stu-id="8eef2-222">For example, the events might go to a real-time analytics service.</span></span> <span data-ttu-id="8eef2-223">En outre, étant donné que le service Scheduler n’a pas besoin d’attendre de réponse, l’ajout d’autres abonnés n’a pas d’incidence sur le chemin du workflow principal.</span><span class="sxs-lookup"><span data-stu-id="8eef2-223">And because the Scheduler doesn't have to wait for a response, adding more subscribers doesn't affect the main workflow path.</span></span>

![](./images/drone-communication.png)

<span data-ttu-id="8eef2-224">Notez que les événements d’état de livraison dérivent des événements d’emplacement de drone.</span><span class="sxs-lookup"><span data-stu-id="8eef2-224">Notice that delivery status events are derived from drone location events.</span></span> <span data-ttu-id="8eef2-225">Par exemple, lorsqu’un drone atteint un emplacement de livraison et dépose un package, le service Delivery traduit cette situation en événement DeliveryCompleted.</span><span class="sxs-lookup"><span data-stu-id="8eef2-225">For example, when a drone reaches a delivery location and drops off a package, the Delivery service translates this into a DeliveryCompleted event.</span></span> <span data-ttu-id="8eef2-226">Ceci constitue un exemple de pensée en termes de modèles de domaine.</span><span class="sxs-lookup"><span data-stu-id="8eef2-226">This is an example of thinking in terms of domain models.</span></span> <span data-ttu-id="8eef2-227">Comme indiqué précédemment, le système de gestion des drones (Drone Management) appartient à un contexte lié distinct.</span><span class="sxs-lookup"><span data-stu-id="8eef2-227">As described earlier, Drone Management belongs in a separate bounded context.</span></span> <span data-ttu-id="8eef2-228">Les événements de drone véhiculent l’emplacement physique d’un drone.</span><span class="sxs-lookup"><span data-stu-id="8eef2-228">The drone events convey the physical location of a drone.</span></span> <span data-ttu-id="8eef2-229">Les événements de livraison représentent quant à eux les changements d’état d’une livraison, ce qui constitue une entité métier différente.</span><span class="sxs-lookup"><span data-stu-id="8eef2-229">The delivery events, on the other hand, represent changes in the status of a delivery, which is a different business entity.</span></span>

## <a name="using-a-service-mesh"></a><span data-ttu-id="8eef2-230">Utilisation d’une maille de services</span><span class="sxs-lookup"><span data-stu-id="8eef2-230">Using a service mesh</span></span>

<span data-ttu-id="8eef2-231">Une *maille de services* est une couche logicielle qui gère les communications interservice.</span><span class="sxs-lookup"><span data-stu-id="8eef2-231">A *service mesh* is a software layer that handles service-to-service communication.</span></span> <span data-ttu-id="8eef2-232">Les mailles de services sont destinées à résoudre la plupart des difficultés répertoriées à la section précédente, et à décharger les microservices proprement dits de la responsabilité de ces aspects en déléguant cette responsabilité à une couche partagée.</span><span class="sxs-lookup"><span data-stu-id="8eef2-232">Service meshes are designed to address many of the concerns listed in the previous section, and to move responsibility for these concerns away from the microservices themselves and into a shared layer.</span></span> <span data-ttu-id="8eef2-233">La maille de services joue le rôle d’un proxy qui intercepte les communications réseau entre les microservices du cluster.</span><span class="sxs-lookup"><span data-stu-id="8eef2-233">The service mesh acts as a proxy that intercepts network communication between microservices in the cluster.</span></span> 

> [!NOTE]
> <span data-ttu-id="8eef2-234">La maille de services consiste un exemple du [modèle Ambassadeur](../patterns/ambassador.md), un service d’assistance qui envoie des requêtes réseau au nom de l’application.</span><span class="sxs-lookup"><span data-stu-id="8eef2-234">Service mesh is an example of the [Ambassador pattern](../patterns/ambassador.md) &mdash; a helper service that sends network requests on behalf of the application.</span></span> 

<span data-ttu-id="8eef2-235">Pour l’instant, les principales options de maille de services dans Kubernetes sont [linkerd](https://linkerd.io/) et [Istio](https://istio.io/).</span><span class="sxs-lookup"><span data-stu-id="8eef2-235">Right now, the main options for a service mesh in Kubernetes are [linkerd](https://linkerd.io/) and [Istio](https://istio.io/).</span></span> <span data-ttu-id="8eef2-236">Ces deux technologies évoluent rapidement.</span><span class="sxs-lookup"><span data-stu-id="8eef2-236">Both of these technologies are evolving rapidly.</span></span> <span data-ttu-id="8eef2-237">Toutefois, voici certaines des fonctionnalités que linkerd et Istio ont en commun :</span><span class="sxs-lookup"><span data-stu-id="8eef2-237">However, some features that both linkerd and Istio have in common include:</span></span> 

- <span data-ttu-id="8eef2-238">Équilibrage de charge au niveau session, basé sur les latences observées ou sur le nombre de requêtes en attente.</span><span class="sxs-lookup"><span data-stu-id="8eef2-238">Load balancing at the session level, based on observed latencies or number of outstanding requests.</span></span> <span data-ttu-id="8eef2-239">Cette fonctionnalité peut améliorer les performances par rapport à l’équilibrage de charge de type Couche 4 fourni par Kubernetes.</span><span class="sxs-lookup"><span data-stu-id="8eef2-239">This can improve performance over the layer-4 load balancing that is provided by Kubernetes.</span></span> 

- <span data-ttu-id="8eef2-240">Acheminement de couche 7 basé sur le chemin d’URL, l’en-tête d’hôte, la version d’API ou toute autre règle de niveau application.</span><span class="sxs-lookup"><span data-stu-id="8eef2-240">Layer-7 routing based on URL path, Host header, API version, or other application-level rules.</span></span>

- <span data-ttu-id="8eef2-241">Nouvelle tentative pour les requêtes ayant échoué.</span><span class="sxs-lookup"><span data-stu-id="8eef2-241">Retry of failed requests.</span></span> <span data-ttu-id="8eef2-242">Une maille de services comprend les codes d’erreur HTTP et peut retenter automatiquement les requêtes ayant échoué.</span><span class="sxs-lookup"><span data-stu-id="8eef2-242">A service mesh understands HTTP error codes, and can automatically retry failed requests.</span></span> <span data-ttu-id="8eef2-243">Vous pouvez configurer le nombre maximal de nouvelles tentatives, ainsi qu’un délai d’expiration afin de limiter la latence maximale.</span><span class="sxs-lookup"><span data-stu-id="8eef2-243">You can configure that maximum number of retries, along with a timeout period in order to bound the maximum latency.</span></span> 

- <span data-ttu-id="8eef2-244">Disjoncteur.</span><span class="sxs-lookup"><span data-stu-id="8eef2-244">Circuit breaking.</span></span> <span data-ttu-id="8eef2-245">Si une instance entraîne un échec continu des requêtes, la maille de services marquera temporairement cette instance comme non disponible.</span><span class="sxs-lookup"><span data-stu-id="8eef2-245">If an instance consistently fails requests, the service mesh will temporarily mark it as unavailable.</span></span> <span data-ttu-id="8eef2-246">Au terme d’une période d’interruption, elle retentera d’utiliser l’instance.</span><span class="sxs-lookup"><span data-stu-id="8eef2-246">After a backoff period, it will try the instance again.</span></span> <span data-ttu-id="8eef2-247">Vous pouvez configurer le disjoncteur en fonction de différents critères, tels que le nombre d’échecs consécutifs.</span><span class="sxs-lookup"><span data-stu-id="8eef2-247">You can configure the circuit breaker based on various criteria, such as the number of consecutive failures,</span></span>  

- <span data-ttu-id="8eef2-248">La maille de services capture les mesures relatives aux appels interservice, comme le volume de requêtes, la latence, les taux d’erreurs et de réussite, ainsi que les tailles de réponse.</span><span class="sxs-lookup"><span data-stu-id="8eef2-248">Service mesh captures metrics about interservice calls, such as the request volume, latency, error and success rates, and response sizes.</span></span> <span data-ttu-id="8eef2-249">La maille de services permet également de procéder à un traçage distribué en ajoutant des informations de corrélation pour chaque tronçon dans une requête.</span><span class="sxs-lookup"><span data-stu-id="8eef2-249">The service mesh also enables distributed tracing by adding correlation information for each hop in a request.</span></span>

- <span data-ttu-id="8eef2-250">Authentification TLS mutuelle pour les appels interservice.</span><span class="sxs-lookup"><span data-stu-id="8eef2-250">Mutual TLS Authentication for service-to-service calls.</span></span>

<span data-ttu-id="8eef2-251">Avez-vous besoin d’une maille de services ?</span><span class="sxs-lookup"><span data-stu-id="8eef2-251">Do you need a service mesh?</span></span> <span data-ttu-id="8eef2-252">Les mailles de services confèrent à un système distribué une valeur ajoutée incontestable.</span><span class="sxs-lookup"><span data-stu-id="8eef2-252">The value they add to a distributed system is certainly compelling.</span></span> <span data-ttu-id="8eef2-253">Si vous ne disposez pas d’une maille de services, vous devrez tenir compte de chacun des défis mentionnés au début de cet article.</span><span class="sxs-lookup"><span data-stu-id="8eef2-253">If you don't have a service mesh, you will need to consider each of the challenges mentioned at the beginning of the chapter.</span></span> <span data-ttu-id="8eef2-254">Vous pouvez résoudre les problèmes de nouvelle tentative, de disjoncteur et de traçage distribué sans recourir à une maille de services ; toutefois, cette dernière épargne ces problèmes aux différents services en les transférant vers une couche dédiée.</span><span class="sxs-lookup"><span data-stu-id="8eef2-254">You can solve problems like retry, circuit breaker, and distributed tracing without a service mesh, but a service mesh moves these concerns out of the individual services and into a dedicated layer.</span></span> <span data-ttu-id="8eef2-255">En revanche, les mailles de services sont une technologie relativement récente qui n’est pas encore arrivée à maturité.</span><span class="sxs-lookup"><span data-stu-id="8eef2-255">On the other hand, service meshes are a relatively new technology that is still maturing.</span></span> <span data-ttu-id="8eef2-256">Le déploiement d’une maille de services augmente la complexité de l’installation et de la configuration du cluster.</span><span class="sxs-lookup"><span data-stu-id="8eef2-256">Deploying a service mesh adds complexity to the setup and configuration of the cluster.</span></span> <span data-ttu-id="8eef2-257">Cette approche peut avoir une incidence sur les performances, car les requêtes sont alors acheminées par le biais du proxy de la maille de services, et les services supplémentaires s’exécutent désormais sur chaque nœud du cluster.</span><span class="sxs-lookup"><span data-stu-id="8eef2-257">There may be performance implications, because requests now get routed through the service mesh proxy, and because extra services are now running on every node in the cluster.</span></span> <span data-ttu-id="8eef2-258">Vous devez donc procéder à un test de performances et de charge approfondi avant de déployer une maille de services en production.</span><span class="sxs-lookup"><span data-stu-id="8eef2-258">You should do thorough performance and load testing before deploying a service mesh in production.</span></span>

> [!div class="nextstepaction"]
> [<span data-ttu-id="8eef2-259">Conception d’API</span><span class="sxs-lookup"><span data-stu-id="8eef2-259">API design</span></span>](./api-design.md)

<!-- links -->

[ingestion-workflow]: ./ingestion-workflow.md
